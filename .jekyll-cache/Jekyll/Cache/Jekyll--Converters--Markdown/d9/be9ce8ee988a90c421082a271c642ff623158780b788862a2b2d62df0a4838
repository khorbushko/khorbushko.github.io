I"W\<p>Recently I have faced with design-related requirements for <code class="language-plaintext highlighter-rouge">Alert</code> on my project - <code class="language-plaintext highlighter-rouge">Image</code> should be shown with rich description and additional actions.</p>

<p>Quick check of existing Alert Api provided by Apple shows that there is nothing exist for showing alert to user with custom <code class="language-plaintext highlighter-rouge">Content</code> either <code class="language-plaintext highlighter-rouge">Image</code> either <code class="language-plaintext highlighter-rouge">TextInput</code>… So I decided to prepare it by myself.
<!--more--></p>
<h2 id="idea">idea</h2>

<p>The very first that need to be designed - it’s <code class="language-plaintext highlighter-rouge">Buttons</code> for alert. Let’s grab idea from <strong>Apple</strong> and introduce our own <code class="language-plaintext highlighter-rouge">Button</code> with separate building functions - one for <code class="language-plaintext highlighter-rouge">destructive</code> and another one for <code class="language-plaintext highlighter-rouge">regular</code> type of button.</p>

<p>I always prefere to separate full implementation into simplest possible components and implement all of them separatly. Also let’s keep in mind the possibility of extension any part of our component.</p>

<p>Now, when we already separate component in to simple parts, let’s try to implement them.</p>

<h2 id="implementation">implementation</h2>

<p>So let’s stard and implement this. To do so, we can define <code class="language-plaintext highlighter-rouge">struct</code> for this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import Foundation
import SwiftUI

struct UniAlertButton {

    enum Variant {
        case destructive
        case regular
    }
}
</code></pre></div></div>

<p>And we need to add builders for buttons. Putting all together, we can have next:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct UniAlertButton {
    
    enum Variant {
        case destructive
        case regular
    }
    
    let content: AnyView
    let action: () -&gt; Void
    let type: Variant
    
    var isDestructive: Bool {
        type == .destructive
    }
    
    static func destructive&lt;Content: View&gt;(
        @ViewBuilder content: @escaping () -&gt; Content,
        action: (() -&gt; Void)? = nil
    ) -&gt; UniAlertButton {
        UniAlertButton(
            content: content,
            action: action ?? { },
            type: .destructive
        )
    }
    
    static func regular&lt;Content: View&gt;(
        @ViewBuilder content: @escaping () -&gt; Content,
        action: @escaping () -&gt; Void
    ) -&gt; UniAlertButton {
        UniAlertButton(
            content: content,
            action: action,
            type: .regular
        )
    }
    
    private init&lt;Content: View&gt;(
        @ViewBuilder content: @escaping () -&gt; Content,
        action: @escaping () -&gt; Void,
        type: Variant
    ) {
        self.content = AnyView(content())
        self.type = type
        self.action = action
    }
}
</code></pre></div></div>

<blockquote>
  <p>Note: <code class="language-plaintext highlighter-rouge">private init</code> - this will restrict anyone to create uncategorized button’s for <code class="language-plaintext highlighter-rouge">Alert</code>.</p>
</blockquote>

<p>Now it’s time to design  <code class="language-plaintext highlighter-rouge">Alert</code> itself. Basically this should be a <code class="language-plaintext highlighter-rouge">View</code> that can be constructed from <code class="language-plaintext highlighter-rouge">Content</code> and attach some buttons (<code class="language-plaintext highlighter-rouge">UniAlertButton</code>) that we already have.</p>

<p>Thus we would like to build our <code class="language-plaintext highlighter-rouge">Alert</code> within <code class="language-plaintext highlighter-rouge">Content</code> with <code class="language-plaintext highlighter-rouge">View</code> type, we need to define this at <code class="language-plaintext highlighter-rouge">struct</code> description:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct UniAlert&lt;Content&gt;: View where Content: View
</code></pre></div></div>

<p>next - add inputParam for <code class="language-plaintext highlighter-rouge">View</code> in order to store <code class="language-plaintext highlighter-rouge">Content</code> and as it done within Apple Alert - <code class="language-plaintext highlighter-rouge">@State</code> about <code class="language-plaintext highlighter-rouge">visibility</code> of <code class="language-plaintext highlighter-rouge">Alert</code>, and don’t forget about buttons (<code class="language-plaintext highlighter-rouge">UniAlertButton</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import Foundation
import SwiftUI

struct UniAlert&lt;Content&gt;: View where Content: View {

    @Binding private (set) var isShowing: Bool
    
    let displayContent: Content
    let buttons: [UniAlertButton]
    
    var body: some View {
		displayContent
	 }
}
</code></pre></div></div>

<p>Now we already should be able to create convenience way of presenting <code class="language-plaintext highlighter-rouge">Alert</code> - usign <code class="language-plaintext highlighter-rouge">View</code> extenstion modifiers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension View {
    
    func uniAlert&lt;Content&gt;(
        isShowing: Binding&lt;Bool&gt;,
        @ViewBuilder content: @escaping () -&gt; Content,
        actions: [UniAlertButton]
    ) -&gt; some View where Content: View {
        UniAlert(
            isShowing: isShowing,
            displayContent: content(),
            buttons: actions
        )
    }
}
</code></pre></div></div>

<p>And if we create some preview for testing purpose with body like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct UniAlert_Previews: PreviewProvider {
    
    static var previews: some View {
        NavigationView {
            Color.white
        }
        .uniAlert(
            isShowing: .constant(true),
            content: {
                VStack {
                    Text("Title")
                        .font(.system(size: 17, weight: .semibold))
                        .padding(.bottom, 8)
                    Text("Subtitle")
                        .font(.system(size: 13, weight: .regular))
                }
                .padding(.bottom, 8)
                .multilineTextAlignment(.center)
                .foregroundColor(Color.black)
            },
            actions: [
                .destructive(content: {
                    Text("Cancel")
                        .foregroundColor(Color.blue)
                        .font(.system(size: 17, weight: .regular))
                }),
                .regular(content: {
                    Text("Continue")
                        .foregroundColor(Color.blue)
                        .font(.system(size: 17, weight: .semibold))
                }, action: { })
            ])
    }
}
</code></pre></div></div>

<p>we can get unexpected result:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-11-27-custom-alert-swiftUI/preview_1.png" alt="preview body" width="250" />
</div>

<p>Heh, good - we know that our content can be rendered as expected. Let’s add all other compomemt and update their position by adding <code class="language-plaintext highlighter-rouge">GeometryReader</code> and by calculating positioning of all components on required places.</p>

<p>Before we proceed, let’s recap how system <code class="language-plaintext highlighter-rouge">Alert</code> handle 2 and 3 or more buttons:</p>

<div style="text-align:center">
<img src="assets/article/2020/11/27/assets/2020-11-27-custom-alert-swiftUI/sample_alert.png" alt="sample alert for mulitply buttons" width="250" />
</div>

<p>Ok, keeping this im mind we should define different building blocks:</p>

<ul>
  <li>determine which approach to use for buttons - position horizontally or vertically (<code class="language-plaintext highlighter-rouge">requireHorizontalPositioning</code>)</li>
  <li>determine presenting context color (<code class="language-plaintext highlighter-rouge">backgroundColorView</code>)</li>
  <li>determine builders for horizontal and vertical buttons with appropriate layouts (<code class="language-plaintext highlighter-rouge">verticalButtonPad</code> and <code class="language-plaintext highlighter-rouge">horizontalButtonsPad</code>)</li>
</ul>

<p>First items is quite easy to achive - just check number of buttons and we are ready to go:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private var requireHorizontalPositioning: Bool {
    let maxButtonPositionedHorizontally = 2
    return buttons.count &gt; maxButtonPositionedHorizontally
}
</code></pre></div></div>

<p>Context color also not a problem:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private func backgroundColorView() -&gt; some View {
    backgroundColor
        .edgesIgnoringSafeArea(.all)
        .opacity(self.isShowing ? 0.8 : 0)
}
</code></pre></div></div>
<blockquote>
  <p>note u may vant to use <code class="language-plaintext highlighter-rouge">@ViewBuilder</code> instead like:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@ViewBuilder
var backgroundColorView: some View {
    backgroundColor
        .edgesIgnoringSafeArea(.all)
        .opacity(self.isShowing ? 0.8 : 0)
}
</code></pre></div>  </div>
</blockquote>

<p>Ok, and last but not least - positioning of content:</p>

<p>Let’s start from easiet part - vertical buttons pad for case when we have 3 or more buttons:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private func verticalButtonPad() -&gt; some View {
    VStack {
        ForEach(0..&lt;buttons.count) {
            Divider()
                .padding([.leading, .trailing], -contentPadding)
            let current = buttons[$0]
            Button(action: {
                current.action()
                withAnimation {
                    self.isShowing.toggle()
                }
            }, label: {
                current.content.frame(height: 30)
            })
        }
    }
}
</code></pre></div></div>
<blockquote>
  <p>note <code class="language-plaintext highlighter-rouge">contentPadding</code> - property that we will use for controlling content padding all over the <code class="language-plaintext highlighter-rouge">Alert</code></p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var contentPadding: CGFloat = 16
</code></pre></div>  </div>
</blockquote>

<p>Basically, we just iterate through all buttons and put them in <code class="language-plaintext highlighter-rouge">VStack</code> with <code class="language-plaintext highlighter-rouge">Divider</code> between them. And adjusting padding.</p>

<p>Next part - is to position horizontal buttons. In similar approach let’s iterate over buttons and put them in <code class="language-plaintext highlighter-rouge">HStack</code> with <code class="language-plaintext highlighter-rouge">Divider</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private func horizontalButtonsPadFor() -&gt; some View {
    VStack {
        Divider()
            .padding([.leading, .trailing], -contentPadding)
        HStack {
            Spacer()
            ForEach(0..&lt;buttons.count) {
                Spacer()
                if $0 != 0 {
                    Divider().frame(height: 50)
                        .padding([.top, .bottom], -8)
                }
                let current = buttons[$0]
                Button(action: {
                    current.action()
                    withAnimation {
                        self.isShowing.toggle()
                    }
                }, label: {
                    current.content.frame(height: 30)
                        .multilineTextAlignment(.center)
                })
                .frame(height: 30)
            }
            Spacer()
        }
    }
}
</code></pre></div></div>

<p>We can organize auto-layout selection like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private func buttonsPad() -&gt; some View {
    VStack {
        if requireHorizontalPositioning {
            verticalButtonPad()
                .padding([.bottom], 12)
        } else {
            horizontalButtonsPadFor()
                .padding([.bottom], 12)
        }
    }
}
</code></pre></div></div>

<p>Ok, now we should combine all together in to <code class="language-plaintext highlighter-rouge">body</code> of the <code class="language-plaintext highlighter-rouge">Alert</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var body: some View {
    ZStack {
        backgroundColorView()
        VStack {
            VStack {
                displayContent
            }
            .padding(contentPadding)
            buttonsPad()
        }
    }
    .edgesIgnoringSafeArea(.all)
}
</code></pre></div></div>

<p>And result:</p>

<div style="text-align:center">
<img src="assets/article/2020/11/27/assets/2020-11-27-custom-alert-swiftUI/preview_2.png" alt="body redndering first attempt" width="250" />
</div>

<p>Ok, so here we can see, that content is stretched to width of View and it hasn’t any background color. We should add few more properties for Alert setup and use them in combination with <code class="language-plaintext highlighter-rouge">GeometryReader</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// at the top of View
var backgroundColor: Color = Color.gray.opacity(0.5)
var contentBackgroundColor: Color = Color.white
var contentCornerRadius: CGFloat = 12
//...

var body: some View {
    GeometryReader { geometry in
        ZStack {
            backgroundColorView()
            let expectedWidth = geometry.size.width * 0.7
            VStack(spacing: 0) {
                VStack {
                    displayContent
                }
                .padding(contentPadding)
                buttonsPad()
            }
            .background(contentBackgroundColor)
            .cornerRadius(contentCornerRadius)
            .shadow(radius: 1)
            .frame(
                minWidth: expectedWidth,
                maxWidth: expectedWidth
            )
            .background(Color.clear)
        }
        .edgesIgnoringSafeArea(.all)
        .zIndex(Double.greatestFiniteMagnitude)
    }
}
</code></pre></div></div>

<p>Result:</p>

<div style="text-align:center">
<img src="assets/article/2020/11/27/assets/2020-11-27-custom-alert-swiftUI/preview_3.png" alt="body redndering with geometry reader" width="250" />
</div>

<p>Ok, much better, but we can see some misalignment for buttons… To fix this, we need to adjust a bit the process how horizontalPad is configured. To do so - pass <code class="language-plaintext highlighter-rouge">width</code> of <code class="language-plaintext highlighter-rouge">View</code> in to building function and apply few changes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private func horizontalButtonsPadFor(_ expectedWidth: CGFloat) -&gt; some View {
    VStack {
        Divider()
            .padding([.leading, .trailing], -contentPadding)
        HStack {
            let sidesOffset = contentPadding * 2
            let maxHorizontalWidth = expectedWidth - sidesOffset
            Spacer()
            ForEach(0..&lt;buttons.count) {
                Spacer()
                if $0 != 0 {
                    Divider().frame(height: 50)
                        .padding([.top, .bottom], -8)
                }
                let current = buttons[$0]
                Button(action: {
                    current.action()
                    withAnimation {
                        self.isShowing.toggle()
                    }
                }, label: {
                    current.content.frame(height: 30)
                        .multilineTextAlignment(.center)
                })
                .frame(maxWidth: maxHorizontalWidth, minHeight: 30)
            }
            Spacer()
        }
    }
}
</code></pre></div></div>

<p>Let’s check the result:</p>

<div style="text-align:center">
<img src="assets/article/2020/11/27/assets/2020-11-27-custom-alert-swiftUI/preview_4.png" alt="body redndering with adjusted horizontal Pad" width="250" />
</div>

<p>Looks good.</p>

<p>Ok,let’s apply few changes in to preview - to check appearence of our <code class="language-plaintext highlighter-rouge">Alert</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var body: some View {
    VStack {
        Button(action: {
            withAnimation {
                isAlertWith2ButtonsShowed.toggle()
            }
        }, label: {
            Text("Show alert")
        })
    }
    .uniAlert(
        isShowing: $isAlertWith2ButtonsShowed,
        content: {
            VStack {
                Text("Title")
                    .font(.system(size: 17, weight: .semibold))
                    .padding(.bottom, 8)
                Text("Subtitle")
                    .font(.system(size: 13, weight: .regular))
            }
            .padding(.bottom, 8)
            .multilineTextAlignment(.center)
            .foregroundColor(Color.black)
        },
        actions: [
            .destructive(content: {
                Text("Cancel")
                    .foregroundColor(Color.blue)
                    .font(.system(size: 17, weight: .regular))
            }),
            .regular(content: {
                Text("Continue")
                    .foregroundColor(Color.blue)
                    .font(.system(size: 17, weight: .semibold))
            }, action: { })
        ]
    )
}
</code></pre></div></div>

<p>Result is quite unexpected:</p>

<div style="text-align:center">
<img src="assets/article/2020/11/27/assets/2020-11-27-custom-alert-swiftUI/preview_5.png" alt="firt's attempt of presenting" width="250" />
</div>

<p>Wow! But the reason is quite simple - we need to tell explicitly what exactly view is shown and what not. To do so - let’s add one more modification:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// add Presenter - the actual view at which we would like to apply `uniAlert`
struct UniAlert&lt;Presenter, Content&gt;: View where Content: View, Presenter: View

// add property to store ref to presenter 
    let presentationView: Presenter
    
// describe when to show/hide this view
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                presentationView.disabled(isShowing) // &lt;-- here

                backgroundColorView()
                ...

// modify extension for building alert by adding new param
extension View {

    func uniAlert&lt;Content&gt;(
        isShowing: Binding&lt;Bool&gt;,
        @ViewBuilder content: @escaping () -&gt; Content,
        actions: [UniAlertButton]
    ) -&gt; some View where Content: View {
        UniAlert(
            isShowing: isShowing,
            displayContent: content(),
            buttons: actions,
            presentationView: self // &lt;--- this one
        )
    }
}

</code></pre></div></div>

<p>Looks like we are done. Let’s try again:</p>

<div style="text-align:center">
<img src="assets/article/2020/11/27/assets/2020-11-27-custom-alert-swiftUI/alert_demo.gif" alt="demo of alert with 2 button" width="250" />
</div>

<p>Great! That’s exactly what we would like to have.
But wait, how about 3 and more buttons? Let’s check:</p>

<div style="text-align:center">
<img src="assets/article/2020/11/27/assets/2020-11-27-custom-alert-swiftUI/demo_alert_3Button.gif" alt="demo of alert with 3 button" width="250" />
</div>

<p>Exactly what we expect.</p>

<h2 id="complete-solution">complete solution</h2>

<p>The complete solution is available here</p>

<script src="https://gist.github.com/khorbushko/de42603c42b9e8dfa87c9e729af0bd09.js"></script>

<h2 id="bonus">bonus</h2>

<p>Alert that we build is good for very simple cases. But let’s think what we will receve if we present this alert on <code class="language-plaintext highlighter-rouge">View</code> that is in <code class="language-plaintext highlighter-rouge">ZStack</code> or on <code class="language-plaintext highlighter-rouge">View</code> that in <code class="language-plaintext highlighter-rouge">TabBar</code> or similar case?. Yes, we will not cover the whole screen, but just a part of <strong>presented</strong> view. That’s not always expected…</p>

<p>How to solve this?</p>

<p>I believe there are many solutions that depends from few factors. At least from iOS supported version. I’m thinking about iOS 13+, so I ended up with combination this solution within <code class="language-plaintext highlighter-rouge">FullScreenPresenter</code> modifier that was covered previously and described here.</p>

<p>Off cause u need to modify a bit solution code like remove presenter reference (thus we use special context for Alert presentation) and modification of extension with <strong>modifier</strong> that we used to create an <code class="language-plaintext highlighter-rouge">Alert</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension View {
    
    func uniAlert&lt;Content&gt;(
        isShowing: Binding&lt;Bool&gt;,
        @ViewBuilder content: @escaping () -&gt; Content,
        actions: [UniAlertButton]
    ) -&gt; some View where Content: View {
        presentContentOverFullScreen(isPresented: isShowing) { appearenceFlag in
            UniAlert(
                isShowing: appearenceFlag,
                displayContent: content(),
                buttons: actions
            )
        }
    }
}
</code></pre></div></div>

<p>You can also think about some extension that will simplify the way how to create alert body</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum UniAlertBuilder {
    
    static func makeTypicalBody(
        title: String,
        message: String
    ) -&gt; some View {
        VStack {
            Text(title)
                .font(.system(size: 17, weight: .semibold))
                .padding(.bottom, 8)
            
            Text(message)
                .font(.system(size: 13, weight: .regular))
        }
        .padding(.bottom, 8)
        .multilineTextAlignment(.center)
        .foregroundColor(Color.black)
    }
    
    // and other ...
}
</code></pre></div></div>

<p>but this is just limited to you. ;]</p>
:ET