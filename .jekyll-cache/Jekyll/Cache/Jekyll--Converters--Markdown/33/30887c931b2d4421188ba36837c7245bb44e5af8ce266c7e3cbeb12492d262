I"=<p><code class="language-plaintext highlighter-rouge">SwiftUI</code> brings for us, developers, the whole new ecosystem for creating complex and responsible <code class="language-plaintext highlighter-rouge">UI</code>.</p>

<p>Thus the entry point for this approach is quite low and u can start producing acceptable <code class="language-plaintext highlighter-rouge">UI</code> after the first 5 min, it’s always better to dive a bit and understand how everything works under the hood. Such knowledge will improve your future work and our developer’s skills. Even more - without understanding how it works, u can’t develop something really interesting and stunning.
<!--more--></p>

<p>Talking about <code class="language-plaintext highlighter-rouge">SwiftUI</code>, the good start point may be <strong><em>understanding View’s lifecycle</em></strong> - how everything is combined and how every part and components of this ecosystem are related one to each other.</p>

<h2 id="lifecycle">Lifecycle</h2>

<p>We may draw a small scheme that visualize the full Lifecycle of a <code class="language-plaintext highlighter-rouge">View</code> as follow:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-16-understanding-swiftUI-View-lifecycle/view_lifecycle.pdf" alt="view_lifecycle" width="550" />
</div>

<p>As u can see - it’s not very complex. But under this simplicity, there is much more. Every action has its mechanism(s) that improve and optimize it.
Let’s review a bit what’s going on when we create and use a <code class="language-plaintext highlighter-rouge">SwiftUI</code>’s <code class="language-plaintext highlighter-rouge">View</code>.</p>

<h2 id="initialization">Initialization</h2>

<p><code class="language-plaintext highlighter-rouge">View</code> is a protocol that requires from us only body definition, we also have one more requirement - <code class="language-plaintext highlighter-rouge">Type</code> that conform to <code class="language-plaintext highlighter-rouge">View</code> protocol should be a value type, thus <code class="language-plaintext highlighter-rouge">struct</code>.</p>

<p>This requirement is not something that u can observe during a compiling time, instead of in runtime u will receive fatalError:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Fatal</span> <span class="nv">error</span><span class="p">:</span> <span class="n">views</span> <span class="n">must</span> <span class="n">be</span> <span class="n">value</span> <span class="nv">types</span><span class="p">:</span> <span class="o">&lt;</span><span class="kt">ViewFromClass</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">file</span> <span class="kt">SwiftUI</span><span class="p">,</span> <span class="n">line</span> <span class="mi">0</span></code></pre></figure>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-16-understanding-swiftUI-View-lifecycle/preview_crash.png" alt="preview_crash" width="350" />
</div>

<p>So View may be only a value type - struct. This means that initialization is quite simple and yet powerful. In most cases compiler create an initializer for us.</p>

<p>During initialization, we also often can create inner <code class="language-plaintext highlighter-rouge">@State</code> variables (should be <code class="language-plaintext highlighter-rouge">private</code>) or pass <code class="language-plaintext highlighter-rouge">@State</code> through <code class="language-plaintext highlighter-rouge">@Binding</code>. Other properties may be observed using various ways such as <code class="language-plaintext highlighter-rouge">@StateObject</code>, <code class="language-plaintext highlighter-rouge">@ObservedValue</code> or <code class="language-plaintext highlighter-rouge">@SceneStorage</code> etc.</p>

<p>So during initialization, we simply create and configure <code class="language-plaintext highlighter-rouge">View</code>’s states and <em>“store”</em> variables in <code class="language-plaintext highlighter-rouge">SwiftUI</code> <code class="language-plaintext highlighter-rouge">ViewGraph</code>.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ViewGraph</code> constructed by private framework <code class="language-plaintext highlighter-rouge">AttributeGraph.framework</code> (/System/Library/PrivateFrameworks/AttributeGraph.framework)</p>
</blockquote>

<p>Result of this initialization - very complex type with Generics, or simply <code class="language-plaintext highlighter-rouge">some View</code>. <code class="language-plaintext highlighter-rouge">some</code> specially designed for hiding actual type. Why? That’s because of a few main reasons:</p>

<ul>
  <li><a href="https://forums.swift.org/t/improving-the-ui-of-generics/22814#heading--missing-type-level-abstraction">type-level abstraction </a></li>
  <li>protection by hiding implementation details (that’s almost the same as the point above)</li>
  <li>simplification</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">some</code> - is <a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html">opaque type</a> that was introduces <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md">here</a>. This type simply hide return value’s type information and only refere to conformed protocol.</p>

  <p><code class="language-plaintext highlighter-rouge">some</code> is opaque type, so all limitation and possibilities are also in place:</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">PAT</code>’s (protocol associated types) can’t be used for opaque type</li>
    <li>these types are identifiable</li>
    <li>can be composed with generic placeholders</li>
  </ul>
</blockquote>

<p>To check the actual type of View, we may create a very simple example:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">counter</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Some Text"</span><span class="p">)</span>
            <span class="p">})</span>
            
            <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter </span><span class="se">\(</span><span class="n">counter</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And if we use <code class="language-plaintext highlighter-rouge">Mirror</code> (aka <code class="language-plaintext highlighter-rouge">print(Mirror(reflecting: self).subjectType)</code>) we can get:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">ModifiedContent</span><span class="o">&lt;</span><span class="kt">VStack</span><span class="o">&lt;</span><span class="kt">TupleView</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">Button</span><span class="o">&lt;</span><span class="kt">Text</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">Text</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">_FrameLayout</span><span class="o">&gt;</span></code></pre></figure>

<p>Quite complex generic type, that can be hidden above <code class="language-plaintext highlighter-rouge">some View</code>.</p>

<blockquote>
  <p>check out any complex <code class="language-plaintext highlighter-rouge">View</code> that u use in a real project - u will observe a huge name of <code class="language-plaintext highlighter-rouge">Type</code>.</p>
</blockquote>

<h2 id="change">Change</h2>

<p>As we already know, <code class="language-plaintext highlighter-rouge">View</code>’s can be redrawn whenever something is changed. This performed very efficiently because of the used mechanism - SwiftUI checks what exactly was changed and redraw only this part (this is also known as <code class="language-plaintext highlighter-rouge">diff</code>).</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">AnyView</code> removes this efficiency because this is type-eraser, so <code class="language-plaintext highlighter-rouge">SwiftUI</code> can’t compare an unknown type with an unknown type, instead, the whole view will be redrawn. So use <code class="language-plaintext highlighter-rouge">AnyView</code> wisely.</p>
</blockquote>

<p>Another essential component of any View - various <code class="language-plaintext highlighter-rouge">@propertyWrappers</code>.</p>

<p>We <del>can’t</del> (<em>actually can but with a lot of efforts</em>) interact within <code class="language-plaintext highlighter-rouge">View</code> and show to user any update without special variables that can change and hold their state independently from <code class="language-plaintext highlighter-rouge">View</code> (thus view is a <code class="language-plaintext highlighter-rouge">struct</code> and any change will recreate/mutate it). Thanks to <code class="language-plaintext highlighter-rouge">@propertyWrappers</code>, we have a template with boiler part code for various purposes needed during the life of <code class="language-plaintext highlighter-rouge">View</code>.</p>

<blockquote>
  <p>I wrote an overview about available <code class="language-plaintext highlighter-rouge">@propertyWrappers</code> in <code class="language-plaintext highlighter-rouge">SwiftUI</code>. You can check it <a href="/article/2020/12/10/swiftUIpropertyWrappers.html">here</a>.</p>
</blockquote>

<p>Anyway, these values are initialized within the view and changed outside of view. The only thing that should be done by <code class="language-plaintext highlighter-rouge">View</code> - is properly reacting to them. And it does. This is done by design. So we should think only about logic now, not about sync the data and view.</p>

<p>The update/redraw <code class="language-plaintext highlighter-rouge">View</code> flow may be as follow:</p>

<ul>
  <li>Find State of View using <code class="language-plaintext highlighter-rouge">Field Descriptor</code></li>
  <li>Inject <code class="language-plaintext highlighter-rouge">ViewGraph</code> into <code class="language-plaintext highlighter-rouge">State</code></li>
  <li>Render <code class="language-plaintext highlighter-rouge">View.body</code></li>
  <li><code class="language-plaintext highlighter-rouge">State</code> is changed</li>
  <li><code class="language-plaintext highlighter-rouge">State</code> notify the <code class="language-plaintext highlighter-rouge">ViewGraph</code> to update view</li>
  <li>Re-render <code class="language-plaintext highlighter-rouge">View.body</code></li>
</ul>

<blockquote>
  <p>if u interested into how <code class="language-plaintext highlighter-rouge">@State</code> might work in details - <a href="https://kateinoigakukun.hatenablog.com/entry/2019/06/09/081831">check this post</a></p>
</blockquote>

<h2 id="events">Events</h2>

<p>Configuration of <code class="language-plaintext highlighter-rouge">View</code>’s states is also simplified - we have few callbacks. In additional, if we need some event handling configuration we may use another <em>dataFlow</em> mechanisms such as <a href="https://developer.apple.com/documentation/swiftui/hstack/onchange(of:perform:)"><code class="language-plaintext highlighter-rouge">onChange(of:perform:)</code></a> or some other <a href="https://developer.apple.com/documentation/swiftui/hstack-view-modifiers"><strong>View Modifiers</strong></a>.</p>

<blockquote>
  <p>check <a href="https://developer.apple.com/documentation/swiftui/state-and-data-flow">this official doc</a> for more about data flow</p>
</blockquote>

<p>If be clear, there are 2 callback that can be used</p>

<ul>
  <li><a href="https://developer.apple.com/documentation/swiftui/hstack/onappear(perform:)"><code class="language-plaintext highlighter-rouge">onAppear(perform:)</code></a></li>
  <li><a href="https://developer.apple.com/documentation/swiftui/view/ondisappear(perform:)"><code class="language-plaintext highlighter-rouge">onDisappear(perform:)</code></a></li>
</ul>

<p>That’s it. The name tells us their purpose by itself.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">VStack</span> <span class="p">{</span>
        <span class="kt">EmptyView</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="n">onAppear</span> <span class="p">{</span>
        <span class="c1">// action</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="n">onDisappear</span> <span class="p">{</span>
        <span class="c1">// action</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>other <a href="https://developer.apple.com/documentation/swiftui/view-input-and-events">input events</a></p>
</blockquote>

<p>In total, we may sum-up all events and update a bit the scheme from the very beginning of the post:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-16-understanding-swiftUI-View-lifecycle/view_lifecycle_comments.pdf" alt="view_lifecycle_comments" width="550" />
</div>

<h2 id="summary">Summary</h2>

<p>Such an elegant design of <code class="language-plaintext highlighter-rouge">View</code>’s lifecycle reduces required effort, amount of code and so bugs.</p>

<blockquote>
  <p>With a declarative <code class="language-plaintext highlighter-rouge">Swift</code> syntax that’s easy to read and natural to write, <code class="language-plaintext highlighter-rouge">SwiftUI</code> works seamlessly with new <code class="language-plaintext highlighter-rouge">Xcode</code> design tools to keep your code and design perfectly in sync (Apple). <a href="https://developer.apple.com/xcode/swiftui/">source</a></p>
</blockquote>
:ET