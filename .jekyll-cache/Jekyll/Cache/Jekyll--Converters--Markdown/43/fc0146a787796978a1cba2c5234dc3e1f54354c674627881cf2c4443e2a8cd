I"7l<p>Rich animations and some cool effects - it’s always something that I try to add when dealing with UI.</p>

<p>In my opinion, a nicely animated transition is much better than just “blink” and simple state change. Off-cause, this requires a bit more time and sometimes no-one didn’t expect to get this animation effect or even didn’t notice that state is changed without animating <code class="language-plaintext highlighter-rouge">View</code>, but the process of creating animation bring some inner satisfaction for me, and as u know <em>“dress for success”</em>.
<!--more--></p>

<p>Today I would like to tell u about transformation in 2D coordinate space and how it can be done in iOS.</p>

<h2 id="transformation">Transformation</h2>

<blockquote>
  <p>Transformation is a process of modifying and re-positioning the existing graphics</p>
</blockquote>

<p>The process of changing something in some coordinate space is called transformation. we may apply different rules of this change, and when we do the same operation we always receive the same result. Transformation in 2D is called 2D transformation.</p>

<p>What can be done in 2D space? Well, the list is next:</p>

<ul>
  <li>translation</li>
  <li>rotation</li>
  <li>scaling</li>
  <li>reflection</li>
  <li>shear</li>
  <li>combination of these effects</li>
</ul>

<p>We may imagine this all operations as a simple XY transformation (in Cartesian space).</p>

<blockquote>
  <p>There is 3 main transformation - translate, rotate, scale, all other transformation may be done using a combination of them or by using specific value as input.</p>
</blockquote>

<h3 id="the-problem">The problem</h3>

<p>If we think a bit about transformation and projective space, we may be faced with an issue - 2 parallel lines can be intersected (in infinity point). The best sample - is a view of the railroad - near the horizont rails meet each other, and so Cartesian or <code class="language-plaintext highlighter-rouge">Euclidian</code> space is not working for us anymore…</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/train.jpg" alt="projection" width="250" />
</div>

<blockquote>
  <p><span>Photo by <a href="https://unsplash.com/@tiagogerken?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Tiago Gerken</a> on <a href="https://unsplash.com/s/photos/train?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span></p>
</blockquote>

<p>This problem is quite old (more than a few centuries), but luckily for us, mathematicians found the <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">solution</a>.</p>

<blockquote>
  <p>This is the point where matrix plays a very important role. If someone from my teachers in school or university tells me the purpose of matrix and how they actually can be used, I think I spend way more time learning this theme.</p>
</blockquote>

<p>When lines meet at the infinity point, in the play comes <code class="language-plaintext highlighter-rouge">Homogeneous</code> coordinates. <code class="language-plaintext highlighter-rouge">Cartesian</code> is a subset of this coordinate space. Homogeneous coordinates are created to express points within N-dimensional coordinates. How? Simply by adding a variable, so</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X = X/variable
Y = Y/variable
</code></pre></div></div>

<p>A real example would be like next</p>

<p>if we have a point</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = {x=1, y=1}
</code></pre></div></div>

<p>in Homogeneous coordinates we get</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = {x=1, y=1, z=1} // because X = X/1 and Y = Y/1
</code></pre></div></div>

<p>and for infinity point</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = {x=1, y=1, z=0} // because X = X/0 (=∞) and Y = Y/1 (=∞)
</code></pre></div></div>
<h4 id="homogeneous-because">Homogeneous because…</h4>

<p>It’s always good to know why something is called in such a way and not in another. So If u wondering why the name is <code class="language-plaintext highlighter-rouge">Homogeneous</code> and not something else, we may review a simple sample of coordinate transformation to discover this as described <a href="http://robotics.stanford.edu/~birch/projective/node4.html">here</a>.</p>

<p>So to make things a bit simpler and easier, let’s review a simple sample</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P1 = {x=1, y=1, z=5}
P2 = {x=10, y=10, z=50}
P3 = {x=100, y=100, z=500}
</code></pre></div></div>

<p>and representation will be</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P1 = { 1/5; 1/5 }
P2 = { 10/50; 10/50 } =&gt; { 1/5; 1/5 }
P3 = { 100/500; 100/500 } =&gt; { 1/5; 1/5 }

</code></pre></div></div>

<p>so the rule is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P1 = { 1a/5a; 1a/5a } =&gt; {x=1a, y=1a, z=5a}
</code></pre></div></div>

<p>This means that 1 point in <code class="language-plaintext highlighter-rouge">Cartesian</code> space may be represented by a few points. This means that these points are <em>“homogeneous”</em> which according to <a href="https://www.merriam-webster.com/dictionary/homogeneous">dictinary</a> means <em>: of the same or a similar kind or nature</em>.</p>

<p>Now, when we know how this transformation in a 2D system can be done, let’s review each variant in detail.</p>

<blockquote>
  <p>The proof that 2 lines can intersect can be found <a href="http://www.songho.ca/math/homogeneous/homogeneous.html">here</a></p>
</blockquote>

<h3 id="performingchanges">PerformingChanges</h3>

<p>Good - now we know how everything works in terms of each point in coordinate space. it’s time to review each transformation one-by-one, to make sure that we understood every operation.</p>

<h4 id="translation">Translation</h4>

<blockquote>
  <p>Transformation is a process of modifying and re-positioning the existing graphics.</p>
</blockquote>

<p>To translate the point we simply should add <code class="language-plaintext highlighter-rouge">X'</code> and <code class="language-plaintext highlighter-rouge">Y'</code> to the original coordinate:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Xnew = Xold + Tx
Ynew = Yold + Ty
</code></pre></div></div>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/translation.pdf" alt="translation_2d" width="350" />
</div>

<p>and if we move this to <code class="language-plaintext highlighter-rouge">Homogeneous</code> coordinate space:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/translation_matrix.pdf" alt="translation_matrix" width="350" />
</div>

<blockquote>
  <p>if u wondering why we should use 3x3 matrix <a href="https://stackoverflow.com/a/10701960/2012219">here is good and simple exeplanation</a>, but making a long story short - for simplicity</p>
</blockquote>

<p>So we use matrix 3x3 for modification. As u can see, by modifying diff values of the matrix we may achieve a different result.</p>

<h5 id="how-read-the-matrix-data">How read the matrix data</h5>

<p>Before we contrinue, it’s good to mention, that matrix that contains no changes is <strong>Identity</strong> matrix - and this matrix contains 1 in diagonal from top left corner to bottom:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/identity_matrix.pdf" alt="identity_matrix" width="200" />
</div>

<p>As u maybe already think, “from the top left corner to the bottom” is not a quite good explanation. Indeed, each component has its name.</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/matrix_name_of_components.pdf" alt="matrix_name_of_components" width="200" />
</div>

<p>Another alternative may be simply named elements with “m” following index of row and column: m11, m12… etc.</p>

<p>How this all data represented in <code class="language-plaintext highlighter-rouge">CocoaTouch</code>? Well, for this purpose we have a slightly simplified version of matrix - called <code class="language-plaintext highlighter-rouge">CGAffineTransform</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public struct CGAffineTransform {
   public var a: CGFloat
   public var b: CGFloat
   public var c: CGFloat
   public var d: CGFloat
   public var tx: CGFloat
   public var ty: CGFloat
   
   public init()
   public init(a: CGFloat, b: CGFloat, c: CGFloat, d: CGFloat, tx: CGFloat, ty: CGFloat)
}
</code></pre></div></div>

<p>As u can see, this is a simple struct, and as mention in <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform">docs</a> - <em>“because the third column is always (0,0,1), the <code class="language-plaintext highlighter-rouge">CGAffineTransform</code> data structure contains values for only the first two columns.”</em></p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/CGAffineTransform_matrix.pdf" alt="CGAffineTransform_matrix" width="200" />
</div>

<p>If we look at both matrix - from theory and <code class="language-plaintext highlighter-rouge">CGAffineTransform</code> provided by Apple, it’s not so hard to see, Apple’s variant it’s something that should be read downstairs.</p>

<p>So, let’s compare how calculation is done:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/calculation.pdf" alt="calculation" width="400" />
</div>

<p>So Apple’s matrix is read downstairs instead of by row, 3rd column not important because it’s always 001 and the result does nothing.</p>

<blockquote>
  <p>Good sample of how the calculation is done can be found <a href="https://sketchytech.blogspot.com/2014/12/explaining-cgaffinetransform-matrix.html">here</a></p>
</blockquote>

<p>This means that u can’t change index m13; m23 and m33 - these items responsible for factor scale in <code class="language-plaintext highlighter-rouge">Homogeneous</code> space.</p>

<blockquote>
  <p>Because the third column is always (0,0,1), the CGAffineTransform data structure contains values for only the first two <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform">columns</a>.</p>
</blockquote>

<h4 id="rotation">Rotation</h4>

<blockquote>
  <p>2D Rotation is a process of rotating an object with respect to an angle in a two-dimensional plane.</p>
</blockquote>

<p>Rotation is a bit hardener operation than translation, and to do this, we should generate new coordinates of point using rotation angle and basic math operation:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/rotation.pdf" alt="rotation" width="400" />
</div>

<blockquote>
  <p>for simplicity Apple provides a convenient way to perform each operation - like <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform/1455666-init"><code class="language-plaintext highlighter-rouge">init(rotationAngle:)</code></a> that perform the same operation as described above:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x cosθ – Y x sinθ
Y' = X x sinθ + Y x cosθ
</code></pre></div>  </div>
</blockquote>

<h4 id="scaling">Scaling</h4>

<blockquote>
  <p>Scaling is a process of modifying or altering the size of objects</p>
</blockquote>

<p>To make scale operation we only need scale koef. Scale operation described below:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/scale.pdf" alt="scale" width="400" />
</div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x Sx
Y' = Y x Sy
</code></pre></div></div>

<blockquote>
  <p>If scaling factor &gt; 1, then the object size is increased.
If scaling factor &lt; 1, then the object size is reduced.</p>
</blockquote>

<h4 id="reflection">Reflection</h4>

<blockquote>
  <p>Reflection is a kind of <strong>rotation</strong> where the angle of rotation is <strong>180</strong> degree</p>
</blockquote>

<p>As was mention at the very beginning of this article - the 3 main transformations are translated, rotate, and scale. This one is marked as separate because it’s quite often used.</p>

<p>As u probably already know - reflection can be done within 2 axis - <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code>. This means that we simply rotate the point. To do so, we need to multiply the coordinate value by <code class="language-plaintext highlighter-rouge">-1</code>:</p>

<p>for reflection over X:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x 1
Y' = Y x -1
</code></pre></div></div>

<p>for reflection over Y:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x -1
Y' = Y x 1
</code></pre></div></div>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/reflection.pdf" alt="reflection" width="400" />
</div>

<h4 id="shear">Shear</h4>

<blockquote>
  <p>Shearing is an ideal technique to change the shape of an existing object in a two-dimensional plane</p>
</blockquote>

<p>Shear can be done in 2 <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> axis. To perform shear we need to define shearing parameter toward <code class="language-plaintext highlighter-rouge">X</code> direction and <code class="language-plaintext highlighter-rouge">Y</code> direction:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = Xold + Shx x Y
Y' = Yold + Shy x X
</code></pre></div></div>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/shear.pdf" alt="shear" width="400" />
</div>

<p>Now we know all the needed thoery and ready to start coding. But before we continue, here is perfect image that desceibe all <a href="https://en.wikipedia.org/wiki/Affine_transformation">common trnasformation in 2D space</a>:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/2D_affine_transformation_matrix.png" alt="2D_affine_transformation_matrix" width="300" />
</div>

<h4 id="composition">composition</h4>

<blockquote>
  <p>Composing Transformation – the process of applying several transformations in succession to form one overall transformation</p>
</blockquote>

<p>As was mention above, we may also use a combination of these effects. But we can be faced with some pitfall - <strong>the order of computation is important</strong>: as standard in GDI the order is Scale, Rotate and Translate (<strong>SRT</strong>). If u perform the same operation in another order (for example TRS) - the result will be different. This is because all changes are done with respect to the origin of coordinates.</p>

<p>Thus u can achieve the same result within non SRT order and different matrix, but it’s always better to use standardized order of operation, so everyone who works within u’r code has the same idea of how it works.</p>

<blockquote>
  <p>check <a href="https://docs.microsoft.com/en-us/dotnet/desktop/winforms/advanced/why-transformation-order-is-significant?view=netframeworkdesktop-4.8">this explanation</a> for more, also this <a href="https://gamedev.stackexchange.com/a/16721">discussion</a> about same topic and <a href="https://bobobobo.wordpress.com/2011/12/20/rotation-translation-vs-translation-rotation/">comparison of result</a></p>
</blockquote>

<p>So the Rule is:</p>

<p>When we write transformations using standard math notation, the closest transformation to the point is applied first:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T R S = T(R(S))
</code></pre></div></div>

<p>first, the object is scaled, then rotated, then translated</p>

<blockquote>
  <p>check <a href="https://mrl.cs.nyu.edu/~dzorin/ig04/lecture05/lecture05.pdf">this lecture</a> for additional explanation</p>
</blockquote>

<p>Affine transformation – transformed point <code class="language-plaintext highlighter-rouge">P’ { x’, y’ }</code> is a linear combination of the original point <code class="language-plaintext highlighter-rouge">P { x, y }</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| x’|   | m11 m12 m13 |  x 
| y’| = | m21 m22 m23 |  y
| y |   | 1   0    0  |  1
</code></pre></div></div>

<p>And remember - any 2D affine transformation can be decomposed into a rotation, followed by scaling, followed by shearing, and followed a translation. (<a href="https://web.cse.ohio-state.edu/~shen.94/681/Site/Slides_files/transformation_review.pdf">source</a>)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Affine matrix = translation x shearing x scaling x rotation
</code></pre></div></div>

<h2 id="practice">Practice</h2>

<p>It’s time to go from theory to practice and <em>get your hands dirty.</em></p>

<h3 id="uikit">UIKit</h3>

<p>Let’s create a simple app, that modifies <code class="language-plaintext highlighter-rouge">CGAffineTransform</code> value in <code class="language-plaintext highlighter-rouge">UIImageView</code>.</p>

<p>So, UI will be simple one:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/uikit.png" alt="uikit_sample_ui" width="300" />
</div>

<p>Code, that under the hood will change this behavior is just modify property <code class="language-plaintext highlighter-rouge">transform</code> of <code class="language-plaintext highlighter-rouge">UIView</code> (<code class="language-plaintext highlighter-rouge">UIImageView</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func changeAndDisplayAffineTransform(
											a: CGFloat? = nil,
											b: CGFloat? = nil, 
											c: CGFloat? = nil,
											d: CGFloat? = nil,
											tx: CGFloat? = nil, 
											ty: CGFloat? = nil
											) {
	let current = targetImageView.transform
	let new = CGAffineTransform(a: a ?? current.a,
	                            b: b ?? current.b,
	                            c: c ?? current.c,
	                            d: d ?? current.d,
	                            tx: tx ?? current.tx,
	                            ty: ty ?? current.ty)
	targetImageView.transform = new
}
</code></pre></div></div>

<p>Now we can test and observe all transormation, that was discussed earlier:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/demo_uiKit_transform.gif" alt="demo_uiKit_transform" width="300" />
</div>

<p>Thanks to Apple’s engineers we even may not think about each of these values in the matrix and use convenience functions to change translation, scale, or rotation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func rotated(by: CGFloat) -&gt; CGAffineTransform
func scaledBy(x: CGFloat, y: CGFloat) -&gt; CGAffineTransform
func translatedBy(x: CGFloat, y: CGFloat) -&gt; CGAffineTransform
</code></pre></div></div>

<blockquote>
  <p>Composition can be done, using <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform/1455996-concatenating"><code class="language-plaintext highlighter-rouge">concatenating(_:)</code></a> function.</p>
</blockquote>

<h3 id="swiftui">SwiftUI</h3>

<p>To make testing easier. let’s build the same UI as we build for <code class="language-plaintext highlighter-rouge">UIKit</code>.</p>

<p>The code for such screen may be as follow:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct ContentView: View {
    
    @State private var aTransform: CGFloat = 1
    @State private var bTransform: CGFloat = 0
    @State private var cTransform: CGFloat = 0
    @State private var dTransform: CGFloat = 1
    @State private var txTransform: CGFloat = 0
    @State private var tyTransform: CGFloat = 0
        
    var body: some View {
        VStack {
            Image("cat")
                .resizable()
                .aspectRatio(1.25, contentMode: .fit)
                .frame(height: 250, alignment: .center)
                .animation(.linear)
            
            VStack {
                VStack {
                    Slider.buildFor(value: $aTransform, in: -1...1, text: { Text("a") })
                    Slider.buildFor(value: $bTransform, in: -1...1, text: { Text("b") })
                    Slider.buildFor(value: $cTransform, in: -1...1, text: { Text("c") })
                    Slider.buildFor(value: $dTransform, in: -1...1, text: { Text("d") })
                    Slider.buildFor(value: $txTransform, in: -1000...1000, text: { Text("tx") })
                    Slider.buildFor(value: $tyTransform, in: -1000...1000, text: { Text("ty") })
                }
                Spacer()
                HStack {
                    Text(
"""
|  a:  \(String(format:"%.02f", aTransform))   b: \(String(format:"%.02f", bTransform))  0.00 |
|  c:  \(String(format:"%.02f", cTransform))   d: \(String(format:"%.02f", dTransform))  0.00 |
|  tx: \(String(format:"%.02f", txTransform))  ty: \(String(format:"%.02f", tyTransform))  1.00 |
"""
                    )
                    .lineLimit(3)
                    .minimumScaleFactor(0.5)
                    
                    Spacer()
                    Button(action: {
                        withAnimation {
                            makeIdentityTransform()
                        }
                    }, label: {
                        Text("Identity")
                    })
                    .padding()
                }
                Spacer()
            }
            .padding()
        }
        .padding()
    }
    
    private func makeIdentityTransform() {
        aTransform = 1
        bTransform = 0
        cTransform = 0
        dTransform = 1
        txTransform = 0
        tyTransform = 0
    }
}

extension Slider where Label == EmptyView, ValueLabel == EmptyView {
    
    static func buildFor&lt;V, C&gt;(
        value: Binding&lt;V&gt;,
        in bounds: ClosedRange&lt;V&gt; = 0...1,
        text: () -&gt; C,
        onEditingChanged: @escaping (Bool) -&gt; Void = { _ in }
    ) -&gt; some View where V : BinaryFloatingPoint,
                         V.Stride : BinaryFloatingPoint,
                         C: View {
        HStack {
            // swift UI bug workaround https://stackoverflow.com/a/64821300/2012219
            text()
            Slider(
                value: value,
                in: bounds,
                onEditingChanged: onEditingChanged,
                label: { EmptyView() }
            )
        }
    }
}
</code></pre></div></div>

<p>Thats produce for us:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/swiftUI.png" alt="swiftUI_UI" width="300" />
</div>

<p>Now, let’s add <code class="language-plaintext highlighter-rouge">transform</code> modification for <code class="language-plaintext highlighter-rouge">Image</code>. To do so, we should use special <code class="language-plaintext highlighter-rouge">GeometryEffect</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .transformEffect(
        .init(
            a: aTransform,
            b: bTransform,
            c: cTransform,
            d: dTransform,
            tx: txTransform,
            ty: tyTransform
        )
    )
</code></pre></div></div>

<blockquote>
  <p>add this after <code class="language-plaintext highlighter-rouge">.frame(height: 250, alignment: .center)</code> line applied to image.</p>
</blockquote>

<p>Run and observer the result:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/demo_swiftUI_transform.gif" alt="demo_swiftUI_transform" width="300" />
</div>

<p>The <code class="language-plaintext highlighter-rouge">API</code> for <code class="language-plaintext highlighter-rouge">SwiftUI</code> also contains similar functions for modification of the <code class="language-plaintext highlighter-rouge">transform</code> property from the <code class="language-plaintext highlighter-rouge">View</code>. Under the hood, it’s using the<code class="language-plaintext highlighter-rouge"> GeometryEffect</code> protocol - a mechanism for changing the appearance of the <code class="language-plaintext highlighter-rouge">View</code>.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">GeometryEffect</code> - An effect that changes the visual appearance of a view, largely without changing its ancestors or descendants.</p>
</blockquote>

<p>If u wondering how <code class="language-plaintext highlighter-rouge">GeometryEffect</code> works, we may create our modification for affine transformation. The effect should return <code class="language-plaintext highlighter-rouge">ProjectionTransform</code> (matrix 3x3) with the result at the end of the transform and for any “transitioned point” of transformation (e.g if all change if 1 and identity are 0, the transition from 0 to 1 can contain few steps).</p>

<p>The simplest version of Effect can be next:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct AffineTransformEffect: GeometryEffect {
    
    var transform: CGAffineTransform
    
    init(
        a: CGFloat? = nil,
        b: CGFloat? = nil,
        c: CGFloat? = nil,
        d: CGFloat? = nil,
        tx: CGFloat? = nil,
        ty: CGFloat? = nil
    ) {
        transform = CGAffineTransform(
            a: a ?? 1,
            b: b ?? 0,
            c: c ?? 0,
            d: d ?? 1,
            tx: tx ?? 0,
            ty: ty ?? 0
        )
    }
    
    func effectValue(size: CGSize) -&gt; ProjectionTransform {
        ProjectionTransform(transform)
    }
}
</code></pre></div></div>

<p>than, replace <code class="language-plaintext highlighter-rouge">transformEffect</code> to :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	.modifier(
	    AffineTransformEffect(
	        a: aTransform,
	        b: bTransform,
	        c: cTransform,
	        d: dTransform,
	        tx: txTransform,
	        ty: tyTransform
	    )
	)
</code></pre></div></div>

<p>build and run the project - the result is the same.</p>

<p><a href="/assets/posts/images/2020-12-08-affineTransformation/sources/sources.zip">Download source here</a></p>
:ET