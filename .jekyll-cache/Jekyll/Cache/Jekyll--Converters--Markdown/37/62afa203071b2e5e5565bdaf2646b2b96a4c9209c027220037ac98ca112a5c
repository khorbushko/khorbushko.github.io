I"òk<p>Rich animations and some cool effects - it‚Äôs always something that I try to add when deal with UI.</p>

<p>On my opinion, nicely animated transition is much beter that just ‚Äúblink‚Äù and simple state change. Off-cause, this require a bit more time and sometimes no-one didn‚Äôt expect to get this animation effect or even didn‚Äôt notice that state is changed without animating <code class="language-plaintext highlighter-rouge">View</code>, but the process of creating animation bring some inner satisfaction for me, and as u know <em>‚Äúdress for success‚Äù</em>.</p>

<p>Today I would like to tell u about transofrmation in 2D coordinate space and how it can be donw in iOS.</p>

<h2 id="transformation">Transformation</h2>

<blockquote>
  <p>Transformation is a process of modifying and re-positioning the existing graphics</p>
</blockquote>

<p>The process of changing something in some coordinate space called transformation. we may apply different rules of this change, and when we do same operation we alsways receive same result. Transformation in 2D called 2D transformation.</p>

<p>What can be done in 2D space? Well the list are next:</p>

<ul>
  <li>translation</li>
  <li>rotation</li>
  <li>scaling</li>
  <li>reflection</li>
  <li>shear</li>
  <li>combination of this effects</li>
</ul>

<p>We may imagine this all operations as simple XY transformation (in Cartesian space).</p>

<blockquote>
  <p>There are 3 main transformation - translate, rotate, scale, all other transformation may be done using combination of them or by using specific value as input.</p>
</blockquote>

<h3 id="the-problem">The problem</h3>

<p>If we think a bit about transformation and projective space, we may faced with issue - 2 parallel lines can be intersected (in infinity point). The best sample - is view of railroad - near the horizont rails meet each other, and so Cartesian or <code class="language-plaintext highlighter-rouge">Euclidian</code> space is not works for us anymore‚Ä¶</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/train.jpg" alt="projection" width="250" />
</div>

<blockquote>
  <p><span>Photo by <a href="https://unsplash.com/@tiagogerken?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Tiago Gerken</a> on <a href="https://unsplash.com/s/photos/train?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span></p>
</blockquote>

<p>This problem is quite old (more than a few centures), but luckely for us, mathematicaians found the <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">solution</a>.</p>

<blockquote>
  <p>This is the point where matrix actully play very important role. If someone from my teachers in school or universite tell me the purpose of matrix and how thay actually can be used, I think I spend way more time by learning this theme.</p>
</blockquote>

<p>When lines meet at inifinity point, in play comes <code class="language-plaintext highlighter-rouge">Homogeneous</code> coordinates. Actually <code class="language-plaintext highlighter-rouge">Cartesian</code> is subset of this coordinate space. Homogeneous coordinates created to express point within N-dimensional coordinates. How? Simply by adding additional variable, so</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X = X/variable
Y = Y/variable
</code></pre></div></div>

<p>A real example would be like next</p>

<p>if we have a point</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = {x=1, y=1}
</code></pre></div></div>

<p>in Homogeneous coordinates we get</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = {x=1, y=1, z=1} // because X = X/1 and Y = Y/1
</code></pre></div></div>

<p>and for infinity point</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = {x=1, y=1, z=0} // because X = X/0 (=‚àû) and Y = Y/1 (=‚àû)
</code></pre></div></div>
<h4 id="homogeneous-because">Homogeneous because‚Ä¶</h4>

<p>It‚Äôs always good to know why somethin called in such way and not in another. So If u wondering why name is <code class="language-plaintext highlighter-rouge">Homogeneous</code> and not something else, we may review a simple sample of coordiate transofmation to discover this as described <a href="http://robotics.stanford.edu/~birch/projective/node4.html">here</a>.</p>

<p>So to make things a bit simpler and easier, let‚Äôs review simple sample</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P1 = {x=1, y=1, z=5}
P2 = {x=10, y=10, z=50}
P3 = {x=100, y=100, z=500}
</code></pre></div></div>

<p>and representation will be</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P1 = { 1/5; 1/5 }
P2 = { 10/50; 10/50 } =&gt; { 1/5; 1/5 }
P3 = { 100/500; 100/500 } =&gt; { 1/5; 1/5 }

</code></pre></div></div>

<p>so the rule is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P1 = { 1a/5a; 1a/5a } =&gt; {x=1a, y=1a, z=5a}
</code></pre></div></div>

<p>This mean that 1 point in <code class="language-plaintext highlighter-rouge">Cartesian</code> space may be represented by a few points. This mean that this points are <em>‚Äúhomogeneous‚Äù</em> which accordint to <a href="https://www.merriam-webster.com/dictionary/homogeneous">dictinary</a> means <em>:of the same or a similar kind or nature</em>.</p>

<p>Now, when we know how this transormation in 2D system can be done, let‚Äôs review each variant in details.</p>

<blockquote>
  <p>The prooff that 2 lines can intersect can be found <a href="http://www.songho.ca/math/homogeneous/homogeneous.html">here</a></p>
</blockquote>

<h3 id="performingchanges">PerformingChanges</h3>

<p>Good - now we know how everything work in terms of each point in coordinate space. it‚Äôs time to review each transformation one-by one, to make sure that we understood every operation.</p>

<h4 id="translation">Translation</h4>

<blockquote>
  <p>Transformation is a process of modifying and re-positioning the existing graphics.</p>
</blockquote>

<p>To translate point we simply should add <code class="language-plaintext highlighter-rouge">X'</code> and <code class="language-plaintext highlighter-rouge">Y'</code> to original coordinate:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Xnew = Xold + Tx
Ynew = Yold + Ty
</code></pre></div></div>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/translation.pdf" alt="translation_2d" width="350" />
</div>

<p>and if we move this to <code class="language-plaintext highlighter-rouge">Homogeneous</code> coordinate space:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/translation_matrix.pdf" alt="translation_matrix" width="350" />
</div>

<blockquote>
  <p>if u wondering why we should use 3x3 matrix <a href="https://stackoverflow.com/a/10701960/2012219">here is good and simple exeplanation</a>, but making long story short - for simplicity</p>
</blockquote>

<p>So we use matrix 3x3 for modification. As u can see, by modifiying diff values of matrix we may achieve different result.</p>

<h5 id="how-read-the-matrix-data">How read the matrix data</h5>

<p>Before we contrinue, it‚Äôs good to mention, that matrix that contains no changes is <strong>Identity</strong> matrix - and this matrix contains 1 in diagonal from top left corner to bottom:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/identity_matrix.pdf" alt="identity_matrix" width="200" />
</div>

<p>As u maybe already think, ‚Äúfrom top left corner to bottom‚Äù is not quite good explanation. Indeed, each component has it‚Äôs own name.</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/matrix_name_of_components.pdf" alt="matrix_name_of_components" width="200" />
</div>

<p>Another alternative may be simply name elements with ‚Äúm‚Äù folowing index of row and colunm: m11, m12‚Ä¶ etc.</p>

<p>How this all data represented in <code class="language-plaintext highlighter-rouge">CocoaTouch</code>? Well, for this purpose we have slightly simplified version of matrix - called <code class="language-plaintext highlighter-rouge">CGAffineTransform</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public struct CGAffineTransform {
   public var a: CGFloat
   public var b: CGFloat
   public var c: CGFloat
   public var d: CGFloat
   public var tx: CGFloat
   public var ty: CGFloat
   
   public init()
   public init(a: CGFloat, b: CGFloat, c: CGFloat, d: CGFloat, tx: CGFloat, ty: CGFloat)
}
</code></pre></div></div>

<p>As u can see, this is simple struct, and as mention in <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform">docs</a> - <em>‚Äúbecause the third column is always (0,0,1), the <code class="language-plaintext highlighter-rouge">CGAffineTransform</code> data structure contains values for only the first two columns.‚Äù</em></p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/CGAffineTransform_matrix.pdf" alt="CGAffineTransform_matrix" width="200" />
</div>

<p>If we look at both matrix - from theory and from <code class="language-plaintext highlighter-rouge">CGAffineTransform</code> provided by Apple, it‚Äôs not so hard to see, the Apple‚Äôs variant it‚Äôs something that should be readed donwstairs.</p>

<p>So, let‚Äôs compare how calculation is done:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/calculation.pdf" alt="calculation" width="400" />
</div>

<p>So Apple‚Äôs matrix is read downstairs instead of by row, 3rd column not important because it‚Äôs alsways 001 and result does nothing.</p>

<blockquote>
  <p>Good sample how calculation done can be found <a href="https://sketchytech.blogspot.com/2014/12/explaining-cgaffinetransform-matrix.html">here</a></p>
</blockquote>

<p>This mean that u can‚Äôt change index m13; m23 and m33 - this items responsible for factor scale in <code class="language-plaintext highlighter-rouge">Homogeneous</code> space.</p>

<blockquote>
  <p>Because the third column is always (0,0,1), the CGAffineTransform data structure contains values for only the first two <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform">columns</a>.</p>
</blockquote>

<h4 id="rotation">Rotation</h4>

<blockquote>
  <p>2D Rotation is a process of rotating an object with respect to an angle in a two dimensional plane.</p>
</blockquote>

<p>Rotation is a bit hardener operation than translation, and to do this, we should generate new coordinates of point using rotation angle and basic math operation:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/rotation.pdf" alt="rotation" width="400" />
</div>

<blockquote>
  <p>for simlicity Apple provide convinience way to perform each operation - like <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform/1455666-init"><code class="language-plaintext highlighter-rouge">init(rotationAngle:)</code></a> that perform same operation as descibed above:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x cosŒ∏ ‚Äì Y x sinŒ∏
Y' = X x sinŒ∏ + Y x cosŒ∏
</code></pre></div>  </div>
</blockquote>

<h4 id="scaling">Scaling</h4>

<blockquote>
  <p>Scaling is a process of modifying or altering the size of objects</p>
</blockquote>

<p>To make scale operation we only need scale koef. Scale operation described below:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/scale.pdf" alt="scale" width="400" />
</div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x Sx
Y' = Y x Sy
</code></pre></div></div>

<blockquote>
  <p>If scaling factor &gt; 1, then the object size is increased.
If scaling factor &lt; 1, then the object size is reduced.</p>
</blockquote>

<h4 id="reflection">Reflection</h4>

<blockquote>
  <p>Reflection is a kind of <strong>rotation</strong> where the angle of rotation is <strong>180</strong> degree</p>
</blockquote>

<p>As was mention in the very beggining of this article - 3 main transformation are translate, rotate and scale. This one is marked as separate because it‚Äôs quite often used.</p>

<p>As u probably already know - reflection can be done within 2 axis - <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code>. This mean that we simply rotate point. To do so, we need to multiply coordinate value by <code class="language-plaintext highlighter-rouge">-1</code>:</p>

<p>for reflection over X:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x 1
Y' = Y x -1
</code></pre></div></div>

<p>for reflection over Y:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = X x -1
Y' = Y x 1
</code></pre></div></div>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/reflection.pdf" alt="reflection" width="400" />
</div>

<h4 id="shear">Shear</h4>

<blockquote>
  <p>Shearing is an ideal technique to change the shape of an existing object in a two dimensional plane</p>
</blockquote>

<p>Shear can be done in 2 <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> axis. To perform shear we need to define shearing parameter toward <code class="language-plaintext highlighter-rouge">X</code> direction and toward <code class="language-plaintext highlighter-rouge">Y</code> direction:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X' = Xold + Shx x Y
Y' = Yold + Shy x X
</code></pre></div></div>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/shear.pdf" alt="shear" width="400" />
</div>

<p>Now we know all the needed thoery and ready to start coding. But before we continue, here is perfect image that desceibe all <a href="https://en.wikipedia.org/wiki/Affine_transformation">common trnasformation in 2D space</a>:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/2D_affine_transformation_matrix.png" alt="2D_affine_transformation_matrix" width="300" />
</div>

<h4 id="composition">composition</h4>

<blockquote>
  <p>Composing Transformation ‚Äì the process of applying several transformation in succession to form one overall transformation</p>
</blockquote>

<p>As was mention above, we may also use combination of this effects. But we can be faced within some pitfall - <strong>the order of computation is important</strong>: as standart in GDI the order is Scale, Rotate and Translate (<strong>SRT</strong>). If u perform same operation in other order (for example TRS) - the result will be different. This is bacause all changes are done in respect to origin of coordinates.</p>

<p>Thus u can achive same result within non SRT order and different matrix, but it‚Äôs always better to use standartized order of operation, so everyone who works within u‚Äôr code have same idea of how it works.</p>

<blockquote>
  <p>check <a href="https://docs.microsoft.com/en-us/dotnet/desktop/winforms/advanced/why-transformation-order-is-significant?view=netframeworkdesktop-4.8">this explanation</a> for more, also this <a href="https://gamedev.stackexchange.com/a/16721">discussion</a> about same topic and <a href="https://bobobobo.wordpress.com/2011/12/20/rotation-translation-vs-translation-rotation/">comparison of result</a></p>
</blockquote>

<p>So the Rule is:</p>

<p>When we write transformations using standard math notation, the closest transformation to the point is applied first:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T R S = T(R(S))
</code></pre></div></div>

<p>first, the object is scaled, then rotated, then translated</p>

<blockquote>
  <p>check <a href="https://mrl.cs.nyu.edu/~dzorin/ig04/lecture05/lecture05.pdf">this lecture</a> for additional explanation</p>
</blockquote>

<p>Affine transformation ‚Äì transformed point <code class="language-plaintext highlighter-rouge">P‚Äô { x‚Äô, y‚Äô }</code> is a linear combination of the original point <code class="language-plaintext highlighter-rouge">P { x, y }</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| x‚Äô|   | m11 m12 m13 |  x 
| y‚Äô| = | m21 m22 m23 |  y
| y |   | 1   0    0  |  1
</code></pre></div></div>

<p>And remember - any 2D affine transformation can be decomposed into a rotation, followed by a scaling, followed by a shearing, and followed by a translation. (<a href="https://web.cse.ohio-state.edu/~shen.94/681/Site/Slides_files/transformation_review.pdf">source</a>)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Affine matrix = translation x shearing x scaling x rotation
</code></pre></div></div>

<h2 id="practice">Practice</h2>

<p>It‚Äôs time to go from theory to practice and <em>get your hands dirty.</em></p>

<h3 id="uikit">UIKit</h3>

<p>Let‚Äôs create simple app, that modify <code class="language-plaintext highlighter-rouge">CGAffineTransform</code> value in <code class="language-plaintext highlighter-rouge">UIImageView</code>.</p>

<p>So, UI will be simple one:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/uikit.png" alt="uikit_sample_ui" width="300" />
</div>

<p>Code, that under the hood will change this behavior is just modify property <code class="language-plaintext highlighter-rouge">transform</code> of <code class="language-plaintext highlighter-rouge">UIView</code> (<code class="language-plaintext highlighter-rouge">UIImageView</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func changeAndDisplayAffineTransform(
											a: CGFloat? = nil,
											b: CGFloat? = nil, 
											c: CGFloat? = nil,
											d: CGFloat? = nil,
											tx: CGFloat? = nil, 
											ty: CGFloat? = nil
											) {
	let current = targetImageView.transform
	let new = CGAffineTransform(a: a ?? current.a,
	                            b: b ?? current.b,
	                            c: c ?? current.c,
	                            d: d ?? current.d,
	                            tx: tx ?? current.tx,
	                            ty: ty ?? current.ty)
	targetImageView.transform = new
}
</code></pre></div></div>

<p>Now we can test and observe all transormation, that was discussed earlier:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/demo_uiKit_transform.gif" alt="demo_uiKit_transform" width="300" />
</div>

<p>Thanks to Apple‚Äôs engineers we even may not think about each of this values in matrix and use convinience functions to change translation, scale or rotation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func rotated(by: CGFloat) -&gt; CGAffineTransform
func scaledBy(x: CGFloat, y: CGFloat) -&gt; CGAffineTransform
func translatedBy(x: CGFloat, y: CGFloat) -&gt; CGAffineTransform
</code></pre></div></div>

<blockquote>
  <p>Composition can be done, using <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform/1455996-concatenating"><code class="language-plaintext highlighter-rouge">concatenating(_:)</code></a> function.</p>
</blockquote>

<h3 id="swiftui">SwiftUI</h3>

<p>To make testing more easy. let‚Äôs build same UI as we build for <code class="language-plaintext highlighter-rouge">UIKit</code>.</p>

<p>The code for such screen may be as follow:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct ContentView: View {
    
    @State private var aTransform: CGFloat = 1
    @State private var bTransform: CGFloat = 0
    @State private var cTransform: CGFloat = 0
    @State private var dTransform: CGFloat = 1
    @State private var txTransform: CGFloat = 0
    @State private var tyTransform: CGFloat = 0
        
    var body: some View {
        VStack {
            Image("cat")
                .resizable()
                .aspectRatio(1.25, contentMode: .fit)
                .frame(height: 250, alignment: .center)
                .animation(.linear)
            
            VStack {
                VStack {
                    Slider.buildFor(value: $aTransform, in: -1...1, text: { Text("a") })
                    Slider.buildFor(value: $bTransform, in: -1...1, text: { Text("b") })
                    Slider.buildFor(value: $cTransform, in: -1...1, text: { Text("c") })
                    Slider.buildFor(value: $dTransform, in: -1...1, text: { Text("d") })
                    Slider.buildFor(value: $txTransform, in: -1000...1000, text: { Text("tx") })
                    Slider.buildFor(value: $tyTransform, in: -1000...1000, text: { Text("ty") })
                }
                Spacer()
                HStack {
                    Text(
"""
|  a:  \(String(format:"%.02f", aTransform))   b: \(String(format:"%.02f", bTransform))  0.00 |
|  c:  \(String(format:"%.02f", cTransform))   d: \(String(format:"%.02f", dTransform))  0.00 |
|  tx: \(String(format:"%.02f", txTransform))  ty: \(String(format:"%.02f", tyTransform))  1.00 |
"""
                    )
                    .lineLimit(3)
                    .minimumScaleFactor(0.5)
                    
                    Spacer()
                    Button(action: {
                        withAnimation {
                            makeIdentityTransform()
                        }
                    }, label: {
                        Text("Identity")
                    })
                    .padding()
                }
                Spacer()
            }
            .padding()
        }
        .padding()
    }
    
    private func makeIdentityTransform() {
        aTransform = 1
        bTransform = 0
        cTransform = 0
        dTransform = 1
        txTransform = 0
        tyTransform = 0
    }
}

extension Slider where Label == EmptyView, ValueLabel == EmptyView {
    
    static func buildFor&lt;V, C&gt;(
        value: Binding&lt;V&gt;,
        in bounds: ClosedRange&lt;V&gt; = 0...1,
        text: () -&gt; C,
        onEditingChanged: @escaping (Bool) -&gt; Void = { _ in }
    ) -&gt; some View where V : BinaryFloatingPoint,
                         V.Stride : BinaryFloatingPoint,
                         C: View {
        HStack {
            // swift UI bug workaround https://stackoverflow.com/a/64821300/2012219
            text()
            Slider(
                value: value,
                in: bounds,
                onEditingChanged: onEditingChanged,
                label: { EmptyView() }
            )
        }
    }
}
</code></pre></div></div>

<p>Thats produce for us:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/swiftUI.png" alt="swiftUI_UI" width="300" />
</div>

<p>Now, let‚Äôs add <code class="language-plaintext highlighter-rouge">transform</code> modification for <code class="language-plaintext highlighter-rouge">Image</code>. To do so, we should use special <code class="language-plaintext highlighter-rouge">GeometryEffect</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .transformEffect(
        .init(
            a: aTransform,
            b: bTransform,
            c: cTransform,
            d: dTransform,
            tx: txTransform,
            ty: tyTransform
        )
    )
</code></pre></div></div>

<blockquote>
  <p>add this after <code class="language-plaintext highlighter-rouge">.frame(height: 250, alignment: .center)</code> line applied to image.</p>
</blockquote>

<p>Run and observer the result:</p>

<div style="text-align:center">
<img src="/assets/posts/images/2020-12-08-affineTransformation/demo_swiftUI_transform.gif" alt="demo_swiftUI_transform" width="300" />
</div>

<p>The <code class="language-plaintext highlighter-rouge">API</code> for <code class="language-plaintext highlighter-rouge">SwiftUI</code> also contains similar functions for modification of the <code class="language-plaintext highlighter-rouge">transform</code> property from the <code class="language-plaintext highlighter-rouge">View</code>. Under the hood it‚Äôs use <code class="language-plaintext highlighter-rouge">GeometryEffect</code> protocol - mechanism for changing appearence of the <code class="language-plaintext highlighter-rouge">View</code>.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">GeometryEffect</code> - An effect that changes the visual appearance of a view, largely without changing its ancestors or descendants.</p>
</blockquote>

<p>If u wondering how <code class="language-plaintext highlighter-rouge">GeometryEffect</code> works, we may create our own modification for affineTransformation. Effect should return <code class="language-plaintext highlighter-rouge">ProjectionTransform</code> (matrix 3x3) with result at the end of transform and for any ‚Äútransitioned point‚Äù of transformation (e.g if all change if 1 and identity is 0, transition form 0 to 1 may contains few steps).</p>

<p>The simplest version of Effect can be next:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct AffineTransformEffect: GeometryEffect {
    
    var transform: CGAffineTransform
    
    init(
        a: CGFloat? = nil,
        b: CGFloat? = nil,
        c: CGFloat? = nil,
        d: CGFloat? = nil,
        tx: CGFloat? = nil,
        ty: CGFloat? = nil
    ) {
        transform = CGAffineTransform(
            a: a ?? 1,
            b: b ?? 0,
            c: c ?? 0,
            d: d ?? 1,
            tx: tx ?? 0,
            ty: ty ?? 0
        )
    }
    
    func effectValue(size: CGSize) -&gt; ProjectionTransform {
        ProjectionTransform(transform)
    }
}
</code></pre></div></div>

<p>than, replace <code class="language-plaintext highlighter-rouge">transformEffect</code> to :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	.modifier(
	    AffineTransformEffect(
	        a: aTransform,
	        b: bTransform,
	        c: cTransform,
	        d: dTransform,
	        tx: txTransform,
	        ty: tyTransform
	    )
	)
</code></pre></div></div>

<p>build and run the project - result exactly same.</p>

<p><a href="/assets/posts/images/2020-12-08-affineTransformation/sources/sources.zip">Download source here</a></p>
:ET